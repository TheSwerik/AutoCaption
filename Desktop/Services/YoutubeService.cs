using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Desktop.Exceptions.YouTubeService;
using Desktop.ViewModels;
using Google;
using Google.Apis.Auth.OAuth2;
using Google.Apis.Auth.OAuth2.Responses;
using Google.Apis.Services;
using Google.Apis.Upload;
using Google.Apis.YouTube.v3;
using Google.Apis.YouTube.v3.Data;

namespace Desktop.Services;

//TODO feature: process now, upload later (would take up not trivial amount of space though)
public static class YoutubeService
{
    private const string YtKey = "YouTube";
    private const string QuotaText = "The request cannot be completed because you have exceeded your";
    private static readonly ILogger Logger = new Logger(nameof(YoutubeService));
    private static readonly ILogger YtdlpLogger = new Logger("yt-dlp");

    private static YouTubeService YouTubeService
    {
        get
        {
            if (field is null) InitYouTubeServiceAsync().Wait();
            return field!;
        }
        set;
    }

    public static bool IsYoutubePath(string path)
    {
        var split = path.Split(':');
        return split.Length >= 2 && split.First().Equals(YtKey);
    }

    public static string? GetYouTubeVideoId(string path)
    {
        return !IsYoutubePath(path) ? null : path[(YtKey.Length + 1)..];
    }

    public static string GetYouTubeVideoUrl(string videoId)
    {
        return $"https://youtu.be/{videoId}";
    }

    /// <summary>
    /// </summary>
    /// <param name="visibilities"></param>
    /// <param name="skip"></param>
    /// <returns></returns>
    /// <exception cref="YouTubeServiceException"></exception>
    public static async Task<ImmutableArray<FileItemViewModel>> GetAllVideosWithoutCustomCaptions(
        YouTubeVisibility[] visibilities,
        int skip = 0
    )
    {
        if (visibilities.Length == 0) throw new NoVisibilitySelectedException();
        List<string> allVideoIds;
        try
        {
            allVideoIds = await GetAllVideoIdsAsync(visibilities);
        }
        catch (QuotaExceededException e)
        {
            throw new QuotaExceededException<ImmutableArray<FileItemViewModel>?>(e);
        }

        var result = new List<FileItemViewModel>();
        foreach (var id in allVideoIds.Skip(skip))
        {
            try
            {
                var captions = await GetLanguagesWithAutoGeneratedCaptions(id);
                var captionFiles = captions.Select(c => new FileItemViewModel($"{YtKey}:{id}") { Language = c.Snippet.Language });
                result.AddRange(captionFiles);
            }
            catch (QuotaExceededException e)
            {
                throw new QuotaExceededException<ImmutableArray<FileItemViewModel>?>(e, [..result]);
            }
        }

        return [..result];
    }

    public static async Task<string> DownloadAudioAsync(string id, string outputPath, CancellationToken ct = default)
    {
        Logger.LogInformation($"Downloading Audio of video {id} to {outputPath}");
        Directory.CreateDirectory(outputPath);

        string[] arguments =
        [
            "-x",
            $"--ffmpeg-location \"{ConfigService.Config.FfmpegLocation}\"",
            "-f bestaudio",
            "--restrict-filenames",
            $"-o \"{outputPath}/%(title)s.%(ext)s\"",
            $"https://youtu.be/{id}"
        ];

        var startInfo = new ProcessStartInfo
        {
            FileName = $"{ConfigService.Config.YtdlpLocation}/yt-dlp.exe",
            Arguments = string.Join(' ', arguments),
            RedirectStandardError = true,
            RedirectStandardOutput = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        using var proc = new Process();
        proc.StartInfo = startInfo;
        proc.EnableRaisingEvents = true;

        var fileName = "";

        proc.ErrorDataReceived += YtdlpErrorLogger;
        proc.OutputDataReceived += YtdlpInfoLogger;
        proc.OutputDataReceived += FilePathParser;

        proc.Start();
        proc.BeginErrorReadLine();
        proc.BeginOutputReadLine();

        try
        {
            await proc.WaitForExitAsync(ct);
        }
        catch (TaskCanceledException)
        {
            proc.Kill();
            throw;
        }

        proc.ErrorDataReceived -= YtdlpErrorLogger;
        proc.OutputDataReceived -= YtdlpInfoLogger;
        proc.OutputDataReceived -= FilePathParser;

        if (proc.ExitCode != 0) throw new YtdlpException(proc.ExitCode);

        Logger.LogInformation($"Downloaded Audio of video {id} to {outputPath}: {fileName}");
        return fileName;

        void FilePathParser(object _, DataReceivedEventArgs args)
        {
            const string extractAudioString = "[ExtractAudio]";
            if (args.Data is null || !args.Data.StartsWith(extractAudioString)) return;

            const string extractionString = "[ExtractAudio] Destination: ";
            if (args.Data.StartsWith(extractionString))
            {
                fileName = args.Data[extractionString.Length..];
            }
            else
            {
                const string noConversionString = "[ExtractAudio] Not converting audio ";
                const string noConversionStringEnd = "; the file is already in a common audio format";
                fileName = args.Data[noConversionString.Length..].Split(noConversionStringEnd)[0];
            }

            Logger.LogDebug($"Found Destination-Information: {fileName}");
        }
    }

    private static void YtdlpInfoLogger(object sender, DataReceivedEventArgs e)
    {
        YtdlpLogger.LogDebug(e.Data);
    }

    private static void YtdlpErrorLogger(object sender, DataReceivedEventArgs e)
    {
        YtdlpLogger.LogError(e.Data);
    }

    /// <summary>
    ///     Quota Cost:
    ///     - 1 unit for channel
    ///     - 1 unit per 50 videos uploaded (visibility-filter sadly does not impact this)
    /// </summary>
    /// <param name="visibilities">The allowed visibilities</param>
    /// <returns></returns>
    private static async Task<List<string>> GetAllVideoIdsAsync(YouTubeVisibility[] visibilities)
    {
        Logger.LogInformation($"Finding all uploads of current channel with visibilities: {string.Join(',', visibilities)}");
        const int pageSize = 50; // this is the maximum
        var visibilityStrings = visibilities.Select(v => v.ToString().ToLowerInvariant()).ToImmutableArray();

        // get "uploads" Playlist
        Logger.LogInformation("Finding own YouTube Channel including Uploads Playlist (1qu)");
        var request = YouTubeService.Channels.List("contentDetails"); // 1 quota unit
        request.Mine = true;
        var channels = await SendRequest(request.ExecuteAsync());

        Logger.LogInformation($"Found {channels.Items.Count} Channels. Picking the first one: {channels.Items[0].Id}");

        var uploadsPlaylistId = channels.Items[0].ContentDetails.RelatedPlaylists.Uploads;
        if (uploadsPlaylistId is null) throw new YouTubeServiceException("Uploads Playlist not found");
        Logger.LogInformation($"Found Uploads-Playlist: {uploadsPlaylistId}");

        // get VideoIDs from Playlist
        var videoIds = new List<string>();
        string? nextToken = null;
        var page = 0;
        do
        {
            // 1 quota unit each
            // Pages quota units total
            var req = YouTubeService.PlaylistItems.List("contentDetails,status");
            req.PlaylistId = uploadsPlaylistId;
            req.MaxResults = pageSize;
            req.PageToken = nextToken;

            Logger.LogInformation($"Listing uploaded Videos of Page {page} (1qu)");
            var response = await SendRequest(req.ExecuteAsync());

            Logger.LogInformation($"Found {response.Items.Count} Videos of Page {page}");
            var ids = response.Items
                .Where(i => visibilityStrings.Any(v => string.Equals(i.Status?.PrivacyStatus, v)))
                .Select(item => item.ContentDetails.VideoId)
                .ToImmutableArray();

            Logger.LogInformation($"Found {ids.Length} Videos fit the visibility check");
            videoIds.AddRange(ids);
            nextToken = response.NextPageToken;
            page++;
        } while (nextToken != null);

        Logger.LogInformation($"Found {videoIds.Count} Videos in total");
        return videoIds;
    }

    private static async Task InitYouTubeServiceAsync(CancellationToken ct = default)
    {
        Logger.LogInformation("Initializing YouTube Service");

        string[] scopes =
        [
            YouTubeService.Scope.YoutubeForceSsl, // read captions
            YouTubeService.Scope.YoutubeUpload // upload captions
        ];

        var stream = new FileStream("client_secret.json", FileMode.Open, FileAccess.Read);
        GoogleClientSecrets? clientSecret = null;
        var i = 0;
        do
        {
            try
            {
                using var src = new CancellationTokenSource();
                src.CancelAfter(TimeSpan.FromMinutes(5));
                clientSecret = await GoogleClientSecrets.FromStreamAsync(stream, src.Token);
                break;
            }
            catch (TaskCanceledException)
            {
                Logger.LogInformation($"Cancelled YouTube Service Login after 5 Minutes on try {i}");
                await stream.DisposeAsync();
                stream = new FileStream("client_secret.json", FileMode.Open, FileAccess.Read);
            }
        } while (i++ < 3);

        await stream.DisposeAsync();

        if (clientSecret is null) throw new YouTubeServiceException("Could not log into YouTube after 3 tries.");
#if DEBUG
        const string userId = "AutoCaptionUserLimitExceeded";
        // const string userId = "AutoCaptionUserLimitNotExceeded";
#else
            const string userId = "AutoCaptionUser";
#endif
        var credential = await GoogleWebAuthorizationBroker.AuthorizeAsync(clientSecret.Secrets, scopes, userId, ct);

        YouTubeService = new YouTubeService(new BaseClientService.Initializer
        {
            HttpClientInitializer = credential,
            ApplicationName = "AutoCaption"
        });
        Logger.LogInformation("YouTube Service Initialized");
    }

    /// <summary>
    ///     Quota Cost: 50 units
    /// </summary>
    /// <param name="videoId"></param>
    /// <returns></returns>
    private static async Task<IEnumerable<Caption>> GetLanguagesWithAutoGeneratedCaptions(string videoId)
    {
        const string autoGeneratedCaptionKind = "asr";
        const string englishCaptionLanguage = "en";

        Logger.LogInformation($"Finding Auto-Generated Captions (50qu): {videoId}");
        // 50 quota units each, ouch
        var request = YouTubeService.Captions.List("snippet", videoId);
        var response = await SendRequest(request.ExecuteAsync());

        var captionsToAdd = new List<Caption>();

        var autoGeneratedCaptions = response.Items.Where(c => c.Snippet.TrackKind.Equals(autoGeneratedCaptionKind)).ToImmutableArray();
        captionsToAdd.AddRange(autoGeneratedCaptions);

        var englishCaptions = response.Items.Where(c => c.Snippet.Language.Equals(englishCaptionLanguage)).ToImmutableArray();
        if (englishCaptions.Length == 0) captionsToAdd.Add(new Caption { Snippet = new CaptionSnippet { Language = "en" } });

        Logger.LogInformation(
            $"Found {autoGeneratedCaptions.Length} Auto-Generated Captions and {englishCaptions.Length} english captions (50qu) of {videoId}: {string.Join(',', autoGeneratedCaptions.Select(c => $"{c.Snippet.Language}"))}");
        Logger.LogInformation($"Adding languages of video {videoId}: {string.Join(',', captionsToAdd.Select(c => $"{c.Snippet.Language}"))}");

        return captionsToAdd;
    }

    /// <summary>
    ///     Quota Cost: 400 units
    /// </summary>
    /// <param name="videoId"></param>
    /// <param name="language"></param>
    /// <param name="path"></param>
    /// <param name="ct"></param>
    /// <returns></returns>
    public static async Task UploadCaptionAsync(string videoId, string language, string path, CancellationToken ct = default)
    {
        Logger.LogInformation($"Uploading caption (400qu): {videoId},  language: {language}, path: {path}");
        var caption = new Caption
        {
            Snippet = new CaptionSnippet
            {
                VideoId = videoId,
                Language = language,
                Name = ConfigService.Config.YouTubeCaptionName
            }
        };

        // var extension = Path.GetExtension(path);
        await using var fs = new FileStream(path, FileMode.Open, FileAccess.Read);
        var insert = YouTubeService.Captions.Insert(caption, "snippet", fs, "application/octet-stream");
        var result = await SendRequest(insert.UploadAsync(ct));
        if (result.Status == UploadStatus.Completed)
        {
            Logger.LogInformation($"Successfully uploaded Caption (400qu): {videoId},  language: {language}, path: {path}");
            return;
        }

        // there was an Exception that got swallowed, so unswallow it:
        try
        {
            throw result.Exception;
        }
        catch (TokenResponseException e)
        {
            throw new AuthorizationException(e.Message, e);
        }
        catch (GoogleApiException e) when (e.Message.Contains(QuotaText))
        {
            throw new QuotaExceededException<string>(e, Path.GetFullPath(path));
        }
        catch (Exception e) when (e is not null && e is not YouTubeServiceException)
        {
            if (e is not null) throw new YouTubeServiceException(e.Message, e);
            throw;
        }
    }

    private static async Task<TValue> SendRequest<TValue>(Task<TValue> executeRequest)
        where TValue : class
    {
        TValue? response = null;
        try
        {
            response = await executeRequest;
            return response;
        }
        catch (TokenResponseException e)
        {
            throw new AuthorizationException(e.Message, e);
        }
        catch (GoogleApiException e) when (e.Message.Contains(QuotaText))
        {
            throw new QuotaExceededException<TValue>(e, response);
        }
        catch (Exception e) when (e is not null && e is not YouTubeServiceException)
        {
            if (e is not null) throw new YouTubeServiceException(e.Message, e);
            throw;
        }
    }
}

[SuppressMessage("ReSharper", "UnusedMember.Global")]
public enum YouTubeVisibility
{
    Public,
    Private,
    Unlisted
}