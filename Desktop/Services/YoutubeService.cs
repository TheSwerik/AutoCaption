using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Desktop.Errors;
using Desktop.Extensions;
using Desktop.Results;
using Desktop.ViewModels;
using Google.Apis.Auth.OAuth2;
using Google.Apis.Services;
using Google.Apis.YouTube.v3;
using Google.Apis.YouTube.v3.Data;

namespace Desktop.Services;

//TODO feature: process now, upload later (would take up not trivial amount of space though)
public static class YoutubeService
{
    private const string YtKey = "YouTube";
    private static readonly ILogger Logger = new Logger(nameof(YoutubeService));
    private static readonly ILogger YtdlpLogger = new Logger("yt-dlp");

    private static YouTubeService YouTubeService
    {
        get
        {
            if (field is null) InitYouTubeServiceAsync().Wait();
            return field!;
        }
        set;
    }

    public static bool IsYoutubePath(string path)
    {
        var split = path.Split(':');
        return split.Length >= 2 && split.First().Equals(YtKey);
    }

    public static string? GetYouTubeVideoId(string path)
    {
        return !IsYoutubePath(path) ? null : path[(YtKey.Length + 1)..];
    }

    public static string GetYouTubeVideoUrl(string videoId)
    {
        return $"https://youtu.be/{videoId}";
    }

    public static async Task<Result<ImmutableArray<FileItemViewModel>, YouTubeServiceError>> GetAllVideosWithoutCustomCaptions(
        YouTubeVisibility[] visibilities,
        int skip = 0
    )
    {
        if (visibilities.Length == 0) return new YouTubeServiceError("At least one visibility has to be chosen");
        var allVideoIds = await GetAllVideoIdsAsync(visibilities);
        if (!allVideoIds.Success) return allVideoIds.Error;
        var result = await allVideoIds.Value.Skip(skip).SelectManyAsync(async id =>
        {
            var captions = await GetLanguagesWithAutoGeneratedCaptions(id);
            return captions.Select(c => new FileItemViewModel($"{YtKey}:{id}") { Language = c.Snippet.Language });
        });
        return result.ToImmutableArray();
    }

    public static async Task<Result<string, YtdlpError>> DownloadAudioAsync(string id, string outputPath, CancellationToken ct = default)
    {
        Logger.LogInformation($"Downloading Audio of video {id} to {outputPath}");
        Directory.CreateDirectory(outputPath);

        string[] arguments =
        [
            "-x",
            $"--ffmpeg-location \"{ConfigService.Config.FfmpegLocation}\"",
            "-f bestaudio",
            $"-o \"{outputPath}/%(title)s.%(ext)s\"",
            $"https://youtu.be/{id}"
        ];

        var startInfo = new ProcessStartInfo
        {
            FileName = $"{ConfigService.Config.YtdlpLocation}/yt-dlp.exe",
            Arguments = string.Join(' ', arguments),
            RedirectStandardError = true,
            RedirectStandardOutput = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        using var proc = new Process();
        proc.StartInfo = startInfo;
        proc.EnableRaisingEvents = true;

        var fileName = "";

        proc.ErrorDataReceived += YtdlpErrorLogger;
        proc.OutputDataReceived += YtdlpInfoLogger;
        proc.OutputDataReceived += FilePathParser;

        proc.Start();
        proc.BeginErrorReadLine();
        proc.BeginOutputReadLine();

        await proc.WaitForExitAsync(ct);

        proc.ErrorDataReceived -= YtdlpErrorLogger;
        proc.OutputDataReceived -= YtdlpInfoLogger;
        proc.OutputDataReceived -= FilePathParser;

        if (proc.ExitCode != 0) return new YtdlpError(proc.ExitCode); //TODO show errors in frontend

        Logger.LogInformation($"Downloaded Audio of video {id} to {outputPath}: {fileName}");
        return fileName;

        void FilePathParser(object _, DataReceivedEventArgs args)
        {
            Console.WriteLine("EWRROR: " + args.Data);
            const string extractionString = "[ExtractAudio] Destination: ";
            if (args.Data is not null && args.Data.StartsWith(extractionString))
            {
                fileName = args.Data[extractionString.Length..];
                Logger.LogDebug($"Found Destination-Information: {fileName}");
            }
        }
    }

    private static void YtdlpInfoLogger(object sender, DataReceivedEventArgs e)
    {
        YtdlpLogger.LogDebug(e.Data);
    }

    private static void YtdlpErrorLogger(object sender, DataReceivedEventArgs e)
    {
        YtdlpLogger.LogError(e.Data);
    }

    /// <summary>
    ///     Quota Cost:
    ///     - 1 unit for channel
    ///     - 1 unit per 50 videos uploaded (visibility-filter sadly does not impact this)
    /// </summary>
    /// <param name="visibilities">The allowed visibilities</param>
    /// <returns></returns>
    private static async Task<Result<List<string>, YouTubeServiceError>> GetAllVideoIdsAsync(YouTubeVisibility[] visibilities)
    {
        Logger.LogInformation($"Finding all uploads of current channel with visibilities: {string.Join(',', visibilities)}");
        const int pageSize = 50; // this is the maximum
        var visibilityStrings = visibilities.Select(v => v.ToString().ToLowerInvariant()).ToImmutableArray();

        // get "uploads" Playlist
        Logger.LogInformation("Finding own YouTube Channel including Uploads Playlist (1qu)");
        var request = YouTubeService.Channels.List("contentDetails"); // 1 quota unit
        request.Mine = true;
        var response = await request.ExecuteAsync();
        Logger.LogInformation($"Found {response.Items.Count} Channels. Picking the first one: {response.Items[0].Id}");

        var uploadsPlaylistId = response.Items[0].ContentDetails.RelatedPlaylists.Uploads;
        if (uploadsPlaylistId is null) return new YouTubeServiceError("Upload Playlist not found"); //TODO
        Logger.LogInformation($"Found Upload-Playlist: {uploadsPlaylistId}");

        // get VideoIDs from Playlist
        var videoIds = new List<string>();
        string? nextToken = null;
        var page = 0;
        do
        {
            // 1 quota unit each
            // Pages quota units total
            var req = YouTubeService.PlaylistItems.List("contentDetails,status");
            req.PlaylistId = uploadsPlaylistId;
            req.MaxResults = pageSize;
            req.PageToken = nextToken;

            Logger.LogInformation($"Listing uploaded Videos of Page {page} (1qu)");
            var resp = await req.ExecuteAsync();

            Logger.LogInformation($"Found {resp.Items.Count} Videos of Page {page}");
            var ids = resp.Items
                .Where(i => visibilityStrings.Any(v => string.Equals(i.Status?.PrivacyStatus, v)))
                .Select(item => item.ContentDetails.VideoId)
                .ToImmutableArray();

            Logger.LogInformation($"Found {ids.Length} Videos fit the visibility check");
            videoIds.AddRange(ids);
            nextToken = resp.NextPageToken;
            page++;
        } while (nextToken != null);

        Logger.LogInformation($"Found {videoIds.Count} Videos in total");
        return videoIds;
    }

    private static async Task InitYouTubeServiceAsync(CancellationToken ct = default)
    {
        Logger.LogInformation("Initializing YouTube Service");
        UserCredential credential;

        await using (var stream = new FileStream("client_secret.json", FileMode.Open, FileAccess.Read))
        {
            string[] scopes =
            [
                YouTubeService.Scope.YoutubeForceSsl, // read captions
                YouTubeService.Scope.YoutubeUpload // upload captions
            ];
            var clientSecret = await GoogleClientSecrets.FromStreamAsync(stream, ct);
            const string userId = "AutoCaptionUser2";
            credential = await GoogleWebAuthorizationBroker.AuthorizeAsync(clientSecret.Secrets, scopes, userId, ct);
        }

        YouTubeService = new YouTubeService(new BaseClientService.Initializer
        {
            HttpClientInitializer = credential,
            ApplicationName = "AutoCaption"
        });
        Logger.LogInformation("YouTube Service Initialized");
    }

    /// <summary>
    ///     Quota Cost: 50 units
    /// </summary>
    /// <param name="videoId"></param>
    /// <returns></returns>
    private static async Task<IEnumerable<Caption>> GetLanguagesWithAutoGeneratedCaptions(string videoId)
    {
        const string autoGeneratedCaptionKind = "asr";
        const string englishCaptionLanguage = "en";

        Logger.LogInformation($"Finding Auto-Generated Captions (50qu): {videoId}");
        // 50 quota units each, ouch
        var request = YouTubeService.Captions.List("snippet", videoId);
        var response = await request.ExecuteAsync();

        var captionsToAdd = new List<Caption>();

        var autoGeneratedCaptions = response.Items.Where(c => c.Snippet.TrackKind.Equals(autoGeneratedCaptionKind)).ToImmutableArray();
        captionsToAdd.AddRange(autoGeneratedCaptions);

        var englishCaptions = response.Items.Where(c => c.Snippet.Language.Equals(englishCaptionLanguage)).ToImmutableArray();
        if (englishCaptions.Length == 0) captionsToAdd.Add(new Caption { Snippet = new CaptionSnippet { Language = "en" } });

        Logger.LogInformation(
            $"Found {autoGeneratedCaptions.Length} Auto-Generated Captions and {englishCaptions.Length} english captions (50qu) of {videoId}: {string.Join(',', autoGeneratedCaptions.Select(c => $"{c.Snippet.Language}"))}");
        Logger.LogInformation($"Adding languages of video {videoId}: {string.Join(',', captionsToAdd.Select(c => $"{c.Snippet.Language}"))}");

        return captionsToAdd;
    }

    /// <summary>
    ///     Quota Cost: 400 units
    /// </summary>
    /// <param name="videoId"></param>
    /// <param name="language"></param>
    /// <param name="path"></param>
    /// <param name="ct"></param>
    /// <returns></returns>
    public static async Task UploadCaptionAsync(string videoId, string language, string path, CancellationToken ct = default)
    {
        Logger.LogInformation($"Uploading caption (400qu): {videoId},  language: {language}, path: {path}");
        var caption = new Caption
        {
            Snippet = new CaptionSnippet
            {
                VideoId = videoId,
                Language = language,
                Name = ConfigService.Config.YouTubeCaptionName
            }
        };

        // var extension = Path.GetExtension(path);
        await using var fs = new FileStream(path, FileMode.Open, FileAccess.Read);
        var insert = YouTubeService.Captions.Insert(caption, "snippet", fs, "application/octet-stream");
        await insert.UploadAsync(ct);
        Logger.LogError("WHAT DID THE NAME DO?????");
        Logger.LogInformation($"Successfully uploaded Caption (400qu): {videoId},  language: {language}, path: {path}");
    }
}

[SuppressMessage("ReSharper", "UnusedMember.Global")]
public enum YouTubeVisibility
{
    Public,
    Private,
    Unlisted
}