using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Desktop.Extensions;
using Desktop.ViewModels;
using Google.Apis.Auth.OAuth2;
using Google.Apis.Services;
using Google.Apis.YouTube.v3;
using Google.Apis.YouTube.v3.Data;

namespace Desktop.Services;

public static class YoutubeService
{
    private const string ytKey = "YouTube";
    private static readonly ILogger YtdlpLogger = new Logger("yt-dlp");

    private static YouTubeService YouTubeService
    {
        get
        {
            if (field is null) InitYouTubeServiceAsync().Wait();
            return field!;
        }
        set;
    }

    public static bool IsYoutubePath(string path)
    {
        var split = path.Split(':');
        return split.Length >= 2 && split.First().Equals(ytKey);
    }

    public static string? GetYouTubeVideoId(string path)
    {
        return !IsYoutubePath(path) ? null : path[(ytKey.Length + 1)..];
    }

    public static string GetYouTubeVideoUrl(string videoId)
    {
        return $"https://youtu.be/{videoId}";
    }

    public static async Task<IEnumerable<FileItemViewModel>> GetAllVideosWithoutCustomCaptions(YouTubeVisibility[] visibilities, int skip = 0)
    {
        var allVideoIds = await GetAllVideoIdsAsync(visibilities);
        return await allVideoIds.Skip(skip).SelectManyAsync(async id =>
        {
            var captions = await GetLanguagesWithAutoGeneratedCaptions(id);
            return captions.Select(c => new FileItemViewModel($"yt:{id}") { Language = c.Snippet.Language });
        });
    }

    public static async Task<string> DownloadAudioAsync(string id, string outputPath, CancellationToken ct = default)
    {
        Directory.CreateDirectory(outputPath);

        string[] arguments =
        [
            "-x",
            $"--ffmpeg-location \"{ConfigService.Config.FfmpegLocation}\"",
            "-f bestaudio",
            $"-o \"{outputPath}/%(title)s.%(ext)s\"",
            $"https://youtu.be/{id}"
        ];

        var startInfo = new ProcessStartInfo
        {
            FileName = $"{ConfigService.Config.YtdlpLocation}/yt-dlp.exe",
            Arguments = string.Join(' ', arguments),
            RedirectStandardError = true,
            RedirectStandardOutput = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        using var proc = new Process();
        proc.StartInfo = startInfo;
        proc.EnableRaisingEvents = true;

        var fileName = "";

        proc.ErrorDataReceived += YtdlpErrorLogger;
        proc.OutputDataReceived += YtdlpInfoLogger;
        proc.OutputDataReceived += FilePathParser;

        proc.Start();
        proc.BeginErrorReadLine();
        proc.BeginOutputReadLine();

        await proc.WaitForExitAsync(ct);

        proc.ErrorDataReceived -= YtdlpErrorLogger;
        proc.OutputDataReceived -= YtdlpInfoLogger;
        proc.OutputDataReceived -= FilePathParser;

        if (proc.ExitCode != 0) throw new Exception("YT-DLP Exitcode: " + proc.ExitCode); //TODO show errors in frontend

        return fileName;

        void FilePathParser(object _, DataReceivedEventArgs args)
        {
            Console.WriteLine("EWRROR: " + args.Data);
            const string extractionString = "[ExtractAudio] Destination: ";
            if (args.Data is not null && args.Data.StartsWith(extractionString)) fileName = args.Data[extractionString.Length..];
        }
    }

    private static void YtdlpInfoLogger(object sender, DataReceivedEventArgs e)
    {
        YtdlpLogger.LogDebug(e.Data);
    }

    private static void YtdlpErrorLogger(object sender, DataReceivedEventArgs e)
    {
        YtdlpLogger.LogError(e.Data);
    }

    /// <summary>
    ///     Quota Cost:
    ///     - 1 unit for channel
    ///     - 1 unit per 50 videos uploaded (visibility-filter sadly does not impact this)
    /// </summary>
    /// <param name="visibilities">The allowed visibilities</param>
    /// <returns></returns>
    private static async Task<IEnumerable<string>> GetAllVideoIdsAsync(YouTubeVisibility[] visibilities)
    {
        const int pageSize = 50; // this is the maximum
        var visibilityStrings = visibilities.Select(v => v.ToString().ToLowerInvariant()).ToImmutableArray();

        // get "uploads" Playlist
        var request = YouTubeService.Channels.List("contentDetails"); // 1 quota unit
        request.Mine = true;
        var response = await request.ExecuteAsync();
        var uploadsPlaylistId = response.Items[0].ContentDetails.RelatedPlaylists.Uploads;

        // get VideoIDs from Playlist
        var videoIds = new List<string>();
        string? nextToken = null;
        do
        {
            // 1 quota unit each
            // Pages quota units total
            var req = YouTubeService.PlaylistItems.List("contentDetails,status");
            req.PlaylistId = uploadsPlaylistId;
            req.MaxResults = 50;
            req.PageToken = nextToken;

            var resp = await req.ExecuteAsync();

            var ids = resp.Items
                .Where(i => visibilityStrings.Any(v => string.Equals(i.Status?.PrivacyStatus, v)))
                .Select(item => item.ContentDetails.VideoId);

            videoIds.AddRange(ids);
            nextToken = resp.NextPageToken;
        } while (nextToken != null);

        return videoIds;
    }

    private static async Task InitYouTubeServiceAsync(CancellationToken ct = default)
    {
        UserCredential credential;

        await using (var stream = new FileStream("client_secret.json", FileMode.Open, FileAccess.Read))
        {
            string[] scopes =
            [
                YouTubeService.Scope.YoutubeForceSsl, // read captions
                YouTubeService.Scope.YoutubeUpload // upload captions
            ];
            var clientSecret = await GoogleClientSecrets.FromStreamAsync(stream, ct);
            const string userId = "AutoCaptionUser";
            credential = await GoogleWebAuthorizationBroker.AuthorizeAsync(clientSecret.Secrets, scopes, userId, ct);
        }

        YouTubeService = new YouTubeService(new BaseClientService.Initializer
        {
            HttpClientInitializer = credential,
            ApplicationName = "AutoCaption"
        });
    }

    /// <summary>
    ///     Quota Cost: 50 units
    /// </summary>
    /// <param name="videoId"></param>
    /// <returns></returns>
    private static async Task<IEnumerable<Caption>> GetLanguagesWithAutoGeneratedCaptions(string videoId)
    {
        const string autoGeneratedCaptionKind = "asr";

        // 50 quota units each, ouch
        var request = YouTubeService.Captions.List("snippet", videoId);
        var response = await request.ExecuteAsync();

        //TODO check audio languages
        //TODO check english always

        return response.Items.Where(c => c.Snippet.TrackKind.Equals(autoGeneratedCaptionKind));
    }

    /// <summary>
    ///     Quota Cost: 400 units
    /// </summary>
    /// <param name="videoId"></param>
    /// <param name="language"></param>
    /// <param name="path"></param>
    /// <param name="ct"></param>
    /// <returns></returns>
    public static async Task UploadCaptionAsync(string videoId, string language, string path, CancellationToken ct = default)
    {
        //TODO logging
        var caption = new Caption
        {
            Snippet = new CaptionSnippet
            {
                VideoId = videoId,
                Language = language,
                Name = "AutoCaption" //TODO what does it do?
            }
        };

        // var extension = Path.GetExtension(path);
        await using var fs = new FileStream(path, FileMode.Open, FileAccess.Read);
        var insert = YouTubeService.Captions.Insert(caption, "snippet", fs, "application/octet-stream");
        await insert.UploadAsync(ct);
    }
}

[SuppressMessage("ReSharper", "UnusedMember.Global")]
public enum YouTubeVisibility
{
    Public,
    Private,
    Unlisted
}